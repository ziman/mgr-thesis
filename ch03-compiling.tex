\chapter{Compiling exceptions}

The basic approach to compiling exceptions was shown in \cite{gmh:exceptions}.
This article provides excellent insight and inspiration how such code can be written
in a language such as Haskell.
However, peculiarities of programming with dependent types will make us
diverge a bit, in details at first, in parts of the design later.

\section{A simple exceptionless language}

All high-level languages in this thesis will be languages of simple, typed
expressions.

Our first language will feature only natural numbers and addition, not even
exceptions. We will implement it to build the auxiliary ecosystem of the
compiler and the skeleton of our development.

\subsection{Type universe}

The first thing we will introduce is the type universe representing the set of
types of expressions of the high-level language. We will index our types with
values of this type (most notably the type \ident{Exp u} of expressions, to
indicate what the type of the expression is), and while we could use Agda types
directly for indexing, with an explicit universe, we get decidable equality of
types and all datatypes conveniently in \ident{Set}. We could parametrize our
modules with the universe but let us just define a fixed one for the sake of
simplicity.

\begin{code}
  infixr 5 _=>_
  data U : Set where
    nat : U
    _=>_ : U -> U -> U
\end{code}

\noindent We will also need the interpretation function \ident{el} that maps
types of our simple language to Agda types so that we can use Agda values in
the modelled language.

\begin{code}
  el : U -> Set
  el nat = Nat
  el (s => t) = el s -> el t
\end{code}

\noindent And, as promised, equality is decidable on the elements of the
universe.

\begin{code}
  -- open import Relation.Nullary using (Dec)
  data Dec (p : Set) : Set where
    yes : p -> Dec p
    no  : ~ p -> Dec p

  -- open import Relation.Binary.PropositionalEquality using (_==_)
  data _==_ {a : Set} (x : a) : a -> Set where
    refl : x == x

  eqDecU : (u v : U) -> Dec (u == v)
  -- body omitted
\end{code}

\noindent We omit the body of \ident{eqDecU} because it's just an ordinary
uninteresting case analysis.

\subsection{Expressions}

The core of the language we are going to model consists of its expressions, of
course. For now, we will support nothing more than (numeric) literals and addition.
However, for further extensibility, we separate the type of binary operators.

The type of binary operators is indexed by the types of the two values that
the operator accepts as arguments; the third index represents the type of
the result of application of the operator on the two values.

\begin{code}
  data Op : U -> U -> U -> Set where
    Plus : Op nat nat nat
\end{code}

\noindent Now we can define the expressions: literals and binary operators.
Note that we index the datatype with elements of the universe \ident{U} so that
the Agda type of an expression also incorporates the type of the expression in
the modelled language.

\begin{code}
  data Exp : U -> Set where
    -- Literals
    Lit : forall {u} -> el u -> Exp u
    -- Binary operators
    Bin : forall {u v w} -> Bin u v w -> Exp u -> Exp v -> Exp w
\end{code}

These two short bits of code make up for the complete definition of the expressions
of our first high-level language.

\subsection{Virtual machine}

We will use a very simple stack machine to run the compiled code.

\subsubsection{Stack}

The stack of
the machine is just a cons-list of values, indexed by types (elements of
\ident{U}) of the values pushed on the stack.  This means that just by looking
at the type of the stack, we can tell how many elements it contains and what
types they have.
\begin{code}
  -- open import Data.List
  infixr 5 _::_
  data List (a : Set) : Set where
    [] : List a
    _::_ : a -> List a -> List a

  Shape : Set
  Shape = List U

  infixr 5 _\scons_
  data Stack : Shape -> Set where
    snil : Stack []
    _\scons_ : forall {u s} -> el u -> Stack s -> Stack (u :: s)
\end{code}
\noindent The literal \ident{snil} represents the empty stack; new values are
pushed onto it using the infix constructor \ident{\_\scons\_}.

\subsubsection{Instructions}

At this stage, the machine supports only two instructions: \ident{PUSH}
and \ident{ADD}.
\begin{code}
  data Instr : Shape -> Shape -> Set where
    PUSH : forall {u s} -> el u -> Instr s (u :: s)
    ADD : forall s -> Instr (nat :: nat :: s) (nat :: s)
\end{code}
The type of instructions is indexed by their action on stack. The first shape
argument is the required stack shape so that the instruction can be executed;
the second shape argument is the resulting shape of the stack after the
instruction has been executed.

For example, the instruction \ident{PUSH} takes any value of the type \ident{el u}
and pushes it onto a stack having any shape \ident{s}, creating a new
stack of the shape \ident{u :: s}.

The instruction \ident{ADD} represents popping two natural numbers from the
stack of any shape with two \ident{nat}s on top of it, (hence
\ident{nat :: nat :: s})
and subsequently pushing their sum onto it, resulting in the shape
\ident{nat :: s}.

\subsubsection{Code}

Finally, code for the stack machine is a sequence of instructions, where
type indices of subsequent instructions match. For example, if one instruction
in the sequence produces a stack of the shape \ident{nat :: nat :: s},
we want the next instruction in the code sequence to accept this shape.

If we regard
$\midt{Instr} : \midt{Shape} \to \midt{Shape} \to \midt{Set}$
as a binary relation on \ident{Shape}, then code is the \emph{transitive reflexive closure}
of \ident{Instr}, which is already included in the Agda standard library as the
module \ident{Data.Star}.

\begin{code}
  -- require import Data.Star
  infixr 5 _<|_
  data Star {a b : Set} (R : a -> b -> Set) : a -> b -> Set where
    \nil : forall {x} -> Star R x x
    _<|_ : forall {x y z} -> R x y -> Star R y z -> Star R x z

  Code : Shape -> Shape -> Set
  Code = Star Instr
\end{code}

\noindent The type of instruction sequences is indexed in exactly the same
manner as the type of single instructions: the first index represents the
acceptable shape of stack before execution of the piece of code; the second
index represents the shape of stack after its execution.

Let us conclude this section with an utility function for concatenation of
instruction sequences, which is actually also included in \ident{Data.Star}.

\begin{code}
  infixr 5 _\app_
  _\app_ : forall {R x y z} -> Star R x y -> Star R y z -> Star R x z
  _\app_ \nil ys = ys
  _\app_ (x <| xs) ys = x <| xs \app ys
\end{code}

\subsection{Compiler}

\subsection{Execution}

\subsection{Correctness}

\section{Adding exceptions, GMH-style}

\section{Termination}
