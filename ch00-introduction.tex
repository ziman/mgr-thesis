\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

% SPJ says:
% 1. Describe the problem
% 2. State your contributions
% ...and that's all.

This thesis deals with the semantics of exceptions in programming languages and its preservation
by the compilation process.

For verifying a~compiler that compiles code from a~high-level language (such as Haskell)
to a~low-level language (such as the x86 assembler), we need (besides other things):
\begin{itemize}
	\item to \emph{state semantics} and properties of exceptions expressed in \emph{high-level} code;
	\item to \emph{state semantics} for \emph{low-level} code that results from the compilation process;
	\item to \emph{prove} that compilation preserves this semantics;
	\item to \emph{formalize} the above three points in a~way that allows for mechanical verification.
\end{itemize}
Clearly, without these ingredients, there is no way to define what correctness of a~compiler actually
means (let alone prove it).

In this thesis, we pursue the above four goals.
Besides these core objectives, we want our solution to have other useful properties, all related
to being usable in practical compiler development:
\begin{itemize}
	\item the specifications should be \emph{runnable}; that is, the result should be a~program
		that can be run, can provide compiled code for given input code pieces, can execute
		the compiled code and produce actual result;
	\item the program should be reasonably \emph{readable} and, albeit verified and provably
		correct, it should convey the mechanism of execution clearly without proof clutter getting
		in the way of comprehension;
	\item the compiled code should be \emph{executable by a~simple machine} (a~stack machine,
		for instance), with no fancy high-level features such as continuations
		or arbitrarily-sized instructions;
	\item there should be an~obvious and \emph{straightforward way to extract} the executable core
		sans proofs into other (mainstream) languages (either manually or automatically)
		for practical use.
\end{itemize}

\noindent The contribution of this thesis is that in the general-purpose dependently-typed
pure functional language \textsc{Agda}, we:
\begin{itemize}
	\item formalize the discussed semantics for a~simple language of expressions
		featuring binary operators\footnote{We actually implement only addition but adding new
		operators is trivial.} and exceptions (this is our high-level language);
	\item explore an approach to design of low-level code that is found in the literature
		and show that in dependent setting, a~different, more suitable design can be used;
	\item formalize the semantics of a~language of instructions for a~simple stack machine,
		which is our target low-level language, using the latter approach;
	\item define a~compiler generating instruction sequences from expressions in the high-level
		language
	\item prove that the semantics is preserved in code generated by this compiler.
\end{itemize}
