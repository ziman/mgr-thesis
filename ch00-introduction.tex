\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

% SPJ says:
% 1. Describe the problem
% 2. State your contributions
% ...and that's all.

This thesis deals with the semantics of exceptions in programming languages and how the semantics
is preserved by the compilation process.

To verify a~compiler that compiles code from a~high-level language (such as Haskell)
to a~low-level language (such as the x86 assembler), we need (besides other things):
\begin{itemize}
	\item to \emph{state semantics} and properties of the \emph{high-level} language;
	\item to \emph{state semantics} for \emph{low-level} code that results from the compilation process;
	\item to \emph{prove} that compilation preserves this semantics;
	\item to \emph{formalize} the above three points in a~way that allows for mechanical verification.
\end{itemize}
Clearly, without these ingredients, there is no way to define what correctness of a~compiler actually
means (let alone prove it).

In this thesis, we pursue the above four goals, focused on a simple language with exceptions.
Besides these core objectives, we want our solution to have other properties, all related
to being useful in practical compiler development:

\begin{itemize}\label{objectives}

	\item the specifications should be \emph{runnable}; that is, the result should be a~program
		that can be run, that can provide compiled code for given input code fragments, and
		that can execute the compiled code, producing actual results;
		
	\item the program should be \emph{readable}. Even though the program may be verified,
		it should still convey the mechanism of execution clearly without proof clutter getting
		in the way of comprehension;
		
	\item the compiled code should be \emph{executable by a~simple machine} (a~stack machine,
		for instance), with fully explicit state and no fancy high-level features such as
		continuations, arbitrarily-sized instructions or implicit stacks;
		
	\item there should be an~obvious and \emph{straightforward way to extract} the executable core
		sans proofs into other (mainstream) languages (either manually or automatically)
		for practical use.
		
\end{itemize}

\noindent The contributions of this thesis are:
\begin{itemize}
	\item We formalize the discussed semantics for a~simple language of expressions
		featuring binary operators\footnote{We actually implement only addition but adding new
		operators is trivial.} and exceptions, using the language as our high-level language
		(Section \ref{sec:expression-semantics});
	\item we explore approaches to the design of execution of low-level code on a~virtual
		machine, first examining an approach found in the
		literature, then presenting a~modified one that is easier to implement in a~dependent
		setting by gradually improving on a naive solution and explaining the choices
		(Sections \ref{sec:own-execution-gmh} to \ref{sec:linearized-code});
	\item we formalize the semantics of a~language of instructions for a~simple stack machine,
		which is our target low-level language, using the latter approach
		(Section \ref{sec:lin-instr-semantics});
	\item we define a~compiler generating instruction sequences from expressions in the high-level
		language (Section \ref{sec:lin-compile});
	\item we prove that the semantics is preserved in code generated by this compiler
		(Section \ref{sec:lin-correctness}).
\end{itemize}

\noindent We use the general-purpose dependently typed pure functional language Agda in
our development.
Readers of this thesis are assumed to have knowledge of functional programming, but
not necessarily dependently typed programming. A~brief introduction to dependent types and
related concepts for the purposes of this thesis will be given in Chapter \ref{chap:dependent-types}.
