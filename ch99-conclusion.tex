\chapter{Discussion}

Finally, we converged to a solution that meets our objectives. While we have diverged from the
paper by Hutton and Wright \cite{gmh:exceptions} in low-level execution-related matters
by using different machine modes for instruction skipping instead of jumping, the overall
direction of our development roughly matches that of the paper.

\section{Further work}

There are \emph{lots} of things in this development that could be improved and many alternatives
to the design choices of ours that could be interesting to explore further.

In \Fref{sec:forks}, we mentioned the transactionality of exceptions in pure code. Transforming
linear code to this form of ``forks'' is not too hard -- although not trivial -- and this
intermediate representation could provide a reasoning bridge between tree-structured expressions
and linear code. The compiler could even emit this intermediate structure first,
linearizing it later, which might facilitate proving the correspondence between ``forks''
and linear code. Such an intermediate structure might then be useful in proving termination and
correctness of the program.

\section{Related work}

Some further work.

\todo{What we have achieved, how the objectives have been met.}

\todo{Forks}

\todo{Measure + GMH approach}

\todo{Hyperdependent code}

\todo{Lambdas}

\todo{Labels}

\todo{Statically typed exceptions}

\todo{Peirce (statically \emph{bound} exceptions)}

\todo{Well-founded recursion, completely machine-like code}

\todo{Scrap types, use stack sizes}

\todo{How should the attached code be structured and referenced from the thesis? Insert references in all appropriate places.}

\todo{Extended handler frames. Generalize for any expression. Exploitable for proving?
Is there some yet undiscovered direct 1:1 correspondence that would trivialize proofs?
C++ has a superhandler that aborts if an uncaught exception occurs.}

\todo{Mention Type Theory?}

\todo{Insert a reference to the Bove-Capretta paper wherever it appears.}

\todo{Add references to the source code.}

\todo{Change ! to $\times$ and vice versa.}

\todo{Snoc-code is not tail-recursive}

\todo{$12$ clauses per binop in correctness lemma: factorize?}

\todo{Add non-breaking spaces}

\todo{Add real-world counterparts, like saying "here the machine would use a label and then just jump to it".}

\todo{Post-hoc: in ``Further work'', describe how mode switches can be replaced by jumps.}

\todo{Goal: execution should be tail-recursive}

\todo{Finally, we converge to the solution by GMH, just from a different direction.}

\todo{Spell-check}

\todo{List prerequisites? haskell familiarity? in the introduction?}

\todo{add extensibility as a goal?}

\todo{Search for \texttt{\textbackslash def \textbackslash @textbottom\{\textbackslash vskip
\textbackslash z@ \textbackslash@plus 14pt\}} in the headers and decrease those 14 pts to
something sane when everything is done.}

\todo{Operator precedence is $0$--$10$, not $0$--$100$.}

\todo{Check quote ``consistency'' vs. ,,consistency''.}

\todo{Consider wording: data type vs. type family. Simple or precise?}

\todo{Proper italics in bibliography. Proper ISO bibliography.}

\todo{Proper typography, capitalization, grammar in bibliography.}

\todo{When will the new bridge be built? (Search for ``can be''.)}

\todo{Discuss the compiler written in Epigram (paper received by mail).}

\todo{Discuss the paper by Chlipala and compcert, perhaps.}

\todo{Mention CompCert and the Leroy's paper.}

\section{Conclusions}
